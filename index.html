<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>è²ªé£Ÿè›‡ Snake + å–®å­—æç¤ºæ¨¡å¼</title>
  <style>
    :root{
      --bg:#0f172a;
      --panel:#111827cc;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --accent:#22c55e;
      --accent-2:#16a34a;
      --danger:#ef4444;
      --grid:#1f2937;
      --tile1:#f59e0b;
      --tile2:#b45309;
      --ok:#34d399;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0; background: radial-gradient(1200px 800px at 70% -10%, #1f2937, var(--bg)); font-family: system-ui,-apple-system,"Segoe UI",Roboto,Noto Sans,"Helvetica Neue",Arial; color:var(--text); display:flex; align-items:center; justify-content:center; padding:16px; flex-direction:column; }
    .app{ width: min(100%, 820px); }
    .header{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px; }
    .title{ font-weight:800; letter-spacing:.5px; font-size: clamp(20px, 3vw, 28px);}    
    .panel{ background:linear-gradient(180deg, #0b1224, #0a0f1f); border:1px solid #1f2937; border-radius:16px; box-shadow:0 10px 30px #0008; }
    .hud{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; gap:10px; flex-wrap:wrap }
    .hud .stat{ display:flex; gap:6px; align-items:center; font-variant-numeric: tabular-nums; }
    .hud .stat b{ font-size:18px }
    .hud .chip{ padding:6px 10px; border-radius:999px; background:#0b1224; border:1px solid #1f2937; color:var(--muted)}

    .wordbox{ display:flex; align-items:center; gap:10px; font-size: clamp(16px, 3vw, 22px); font-weight:700 }
    #wordHint{ letter-spacing:2px; color:var(--ok) }

    canvas{ width:100%; height:auto; display:block; background:linear-gradient(180deg,#0a1326,#091021); border-radius:12px; border:1px solid #1e293b; margin-top:12px; }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div class="title">ğŸŸ© è²ªé£Ÿè›‡ Snake Â· å–®å­—æç¤ºæ¨¡å¼</div>
    </div>

    <div class="panel hud">
      <div class="stat">åˆ†æ•¸ï¼š<b id="score">0</b></div>
      <div class="stat">æœ€ä½³ï¼š<b id="best">0</b></div>
      <div class="stat chip">å‰©é¤˜å–®å­—ï¼š<b id="leftCnt">0</b></div>
      <div class="wordbox">
        <span>æç¤ºï¼š</span>
        <span id="wordHint"></span>
      </div>
    </div>

    <div class="panel">
      <canvas id="game" width="360" height="360"></canvas>
    </div>
  </div>

  <script>
    const GRID=12, CELL=30, CANVAS_SIZE=GRID*CELL; // å°ç¯„åœï¼Œå¤§æ ¼å­
    const canvas=document.getElementById('game');
    const ctx=canvas.getContext('2d');
    canvas.width=CANVAS_SIZE; canvas.height=CANVAS_SIZE;

    const scoreEl=document.getElementById('score');
    const bestEl=document.getElementById('best');
    const leftCntEl=document.getElementById('leftCnt');
    const wordHint=document.getElementById('wordHint');

    const BEST_KEY='snake_best_score_v11';
    let rng=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

    // å¾ english.txt è¼‰å…¥ [è‹±æ–‡, ä¸­æ–‡æç¤º]
    async function loadWords(){
      try{
        const resp=await fetch('english.txt?v='+Date.now(),{cache:'no-store'});
        const text=await resp.text();
        const lines=text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l);
        return lines.map(line=>{
          const [en,zh]=line.split(',');
          return [en.trim().toUpperCase(), (zh||'').trim()];
        }).filter(p=>p[0]);
      }catch(e){
        console.error(e);
        return [["APPLE","è˜‹æœ"],["BANANA","é¦™è•‰"]];
      }
    }

    let state={running:true, over:false, score:0, best:parseInt(localStorage.getItem(BEST_KEY)||'0',10), snake:[], dir:{x:1,y:0}, food:[], words:[], queue:[], currentWord:null, currentHint:"", progress:0, lastTouch:null};

    function init(){
      state.snake=[{x:3,y:3},{x:2,y:3},{x:1,y:3}];
      state.score=0; state.over=false;
      state.queue=[...state.words];
      newWord();
      updateHUD();
      draw();
    }

    function newWord(){
      const pair=state.queue.shift()||null;
      if(!pair){ gameClear(); return; }
      state.currentWord=pair[0];
      state.currentHint=pair[1];
      state.progress=0;
      updateHint();
      spawnLetters();
      updateHUD();
    }

    function updateHint(){
      wordHint.textContent = state.currentHint;
    }

    function updateHUD(){
      scoreEl.textContent=state.score;
      bestEl.textContent=state.best;
      // å‰©é¤˜å–®å­—æ•¸ï¼šqueue å…§çš„å­— + ç•¶å‰æ˜¯å¦æœ‰å–®å­—æœªå®Œæˆ
      const remaining = state.queue.length + (state.currentWord && state.progress < state.currentWord.length ? 1 : 0);
      leftCntEl.textContent=remaining;
    }

    function spawnLetters(){
      state.food=[];
      const correct=state.currentWord[state.progress];
      placeLetter(correct);
      const alphabet="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      for(let i=0;i<2;i++){
        let fake;
        do{ fake=alphabet[rng(0,25)]; }while(fake===correct);
        placeLetter(fake);
      }
    }

    function placeLetter(ch){
      let p; const occ=new Set(state.snake.map(p=>p.x+","+p.y));
      do{p={x:rng(0,GRID-1),y:rng(0,GRID-1)}}while(occ.has(p.x+","+p.y));
      state.food.push({x:p.x,y:p.y,char:ch});
    }

    function tick(){
      const head=state.snake[0];
      const nx=head.x+state.dir.x, ny=head.y+state.dir.y;
      if(nx<0||nx>=GRID||ny<0||ny>=GRID){gameOver();return;}
      const newHead={x:nx,y:ny};
      if(state.snake.some((p,i)=>i>0&&p.x===nx&&p.y===ny)){gameOver();return;}
      state.snake.unshift(newHead);
      let ate=false;
      for(const f of state.food){
        if(f.x===nx&&f.y===ny){
          if(state.currentWord[state.progress] && f.char===state.currentWord[state.progress]){
            state.progress++; state.score++;
            if(state.progress>=state.currentWord.length){ newWord(); }
            else{ spawnLetters(); updateHUD(); }
          }
          ate=true; break;
        }
      }
      if(!ate) state.snake.pop();
      draw();
    }

    function draw(){
      ctx.fillStyle="#000";ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
      // é£Ÿç‰© (å­—æ¯æ”¾å¤§)
      for(const f of state.food){
        ctx.fillStyle="#f59e0b";ctx.beginPath();ctx.roundRect(f.x*CELL+2,f.y*CELL+2,CELL-4,CELL-4,6);ctx.fill();
        ctx.fillStyle="#fff";ctx.strokeStyle="#000";ctx.lineWidth=3;
        ctx.font="bold 28px sans-serif";ctx.textAlign="center";ctx.textBaseline="middle";
        ctx.strokeText(f.char,f.x*CELL+CELL/2,f.y*CELL+CELL/2);
        ctx.fillText(f.char,f.x*CELL+CELL/2,f.y*CELL+CELL/2);
      }
      // è›‡
      for(let i=0;i<state.snake.length;i++){
        const p=state.snake[i];
        const x=p.x*CELL,y=p.y*CELL;
        ctx.fillStyle=i===0?"#22c55e":"#16a34a";
        ctx.beginPath();ctx.roundRect(x+2,y+2,CELL-4,CELL-4,5);ctx.fill();
        if(i===0){
          ctx.fillStyle="#000";
          ctx.beginPath();ctx.arc(x+CELL*0.35,y+CELL*0.4,3,0,Math.PI*2);ctx.fill();
          ctx.beginPath();ctx.arc(x+CELL*0.65,y+CELL*0.4,3,0,Math.PI*2);ctx.fill();
        }
      }
      if(state.over){
        ctx.fillStyle="#000a";ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
        ctx.fillStyle="#fff";ctx.font="bold 28px sans-serif";ctx.textAlign="center";
        ctx.fillText(state.cleared?"é€šé—œæˆåŠŸ!":"éŠæˆ²çµæŸ",CANVAS_SIZE/2,CANVAS_SIZE/2);
      }
      updateHUD();
    }

    function gameOver(){ state.over=true; state.cleared=false; }
    function gameClear(){ state.over=true; state.cleared=true; draw(); }

    document.addEventListener('keydown',e=>{
      if(e.key==="ArrowUp") state.dir={x:0,y:-1};
      if(e.key==="ArrowDown") state.dir={x:0,y:1};
      if(e.key==="ArrowLeft") state.dir={x:-1,y:0};
      if(e.key==="ArrowRight") state.dir={x:1,y:0};
    });

    // è§¸æ§æ»‘å‹•æ§åˆ¶
    canvas.addEventListener('touchstart',e=>{
      const t=e.touches[0];
      state.lastTouch={x:t.clientX,y:t.clientY};
    },{passive:true});
    canvas.addEventListener('touchend',e=>{
      if(!state.lastTouch) return;
      const t=e.changedTouches[0];
      const dx=t.clientX-state.lastTouch.x;
      const dy=t.clientY-state.lastTouch.y;
      if(Math.abs(dx)>Math.abs(dy)){
        if(dx>20) state.dir={x:1,y:0};
        if(dx<-20) state.dir={x:-1,y:0};
      }else{
        if(dy>20) state.dir={x:0,y:1};
        if(dy<-20) state.dir={x:0,y:-1};
      }
      state.lastTouch=null;
    },{passive:true});

    (async()=>{
      state.words=await loadWords();
      init();
      setInterval(()=>{if(!state.over) tick();},250); // æ”¾æ…¢é€Ÿåº¦
    })();
  </script>
</body>
</html>